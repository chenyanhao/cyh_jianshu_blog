首先一个事实要澄清：历史上先有 fp，然后有 oop，最后出现的才是 c 这种过程式，不妨简称为 pp；后面的发展只是 pp 上面加上了 oop，然后再加上 fp。

重点在这篇文章的最后。


**第一阶段：**
c 因为最靠近硬件，因此最快，所以任何靠近硬件的软件，都适合 c 来写。
然后呢？人就闲不住了，想封装、想让人编程更简单，至于机器累点，那就累点吧，没关系，毕竟 **人** 才是大爷。

**第二阶段**
所以就开始往 pp 上加 oop 的东西，于是 c++ 就出来了。
但是做大了之后发现，这个 c++ 还是不够，封装还是不够彻底，于是 java 横空出世。

**第三阶段：**
java 说，别废话了，我们不管性能怎样，你把所有代码都给我封装起来，哪怕它慢，你也这么做。
这是正确的路，java 一开始确实性能不行，所以当时很多行业都不适合 java，但是互联网当时本来也很慢，所以无所谓了，没事，等着呗，然后 java 再一次又一次迭代更新自己。

时至今日，java 的性能已经非常理想了，哪怕是一些 low latency 的领域，现实中也都有办法用 java 了，这个趋势只会越来越明显，以前 java 的 gc 比较慢，cms 上个几秒很正常。

但是 g1 开始普及之后，100ms gc pause 将成为常态，以后 zgc 之后，10ms gc pause将成为常态。

所以你会发现，oop 也就是 java 这一层的封装也接近完成了，可能还有一些时效性较高的领域现在还不是 java 主流，但是也指日可待了。

> 如果我们从 pp->oop 这个发展中得到经验的话，那 oop->fp 似乎也是可以预测的了。

**那如果 c 提供了 os，c++ 提供了 jvm，那 java 是不是也应该提供点什么呢？**

**第四阶段：**
当然啦，应该提供 vert.x 嘛，将线程和并发封装起来，下一步呢？在 oop 上加 fp 特性。
这就是 scala 啊，再下一步呢？用 scala 提供一个 fp 的 runtime，对吧？

嗯，那就是 haskell 咯，当然我们也需要 lisp，因为犹如 java oop 还不够有人会用 kotlin 一样。
我们也会用 jvm 上的 lisp，which is clojure，所说到底有没有工业基础，看有没有工具提供出来。

这条线路就演化成为：**os -> jvm -> vert.x -> fp runtime**
这才是正确的路，一层层封装上去。然后降低使用门槛，比如提供几个 gui 让不懂 c、c++ 和 java 的人，也能够很快用上 lisp/clojure。并且能够写出工业界可以直接用的代码，which is verticle，那这两步完成之后，lisp 工业使用的基础也就有了。

你会看到哈，犹如 c 写 os、c++ 写 jvm、java 写 vert.x 一样，我们封装出 lisp 的 runtime 将不需要用户懂什么是 os、什么是 jvm、什么是 vert.x、什么是 gui、什么是 opengl、什么是 directx，将一切都傻瓜化来，那么使用的基础就有了。


在此基础之上，我们可以对同一个系统内部做模块化的整合，比如你用 java 写某一个模块，用 lisp/clojure 写另外一个模块，而不需要做系统层面的整合，比如 soa，web service，那是很糟糕的整合方式，因为成本太高了。
如果一个企业要使用 lisp/clojure，它需要从 make 工具、ide 之类的整个弄一个新的来，那没有企业愿意尝试 lisp/clojure。
但是如果在现有的环境中，只需要一个插件，一个依赖，就能用上 clojure，那为什么不试试呢？很方便，rollback 的成本很低，为什么不？

所以当我们看到了这个趋势之后，**对于 jvm 的发展趋势也就很好预测了**。

# 划重点

理清了发展思路，可以从中认识到：**我们要承认和正视问题的存在，不要回避和逃避问题，遇到问题解决问题，往前走，不要往后退。**

所以个人观点(吹逼扯淡、言之成理即可)来说，很看不上 kotlin 等类似这种东西。正视问题，依托强大的基础，不断的解决问题，不断前进。而不是遇到困难就另起炉灶，在“浮层筑高台”，解决一个问题的同时引入新的问题。

> kotlin 我称其为二奶语言，顾名思义就是二奶。就跟男人的情人一样，利用男人上位，然后打败原配，获取遗产；接着自己做大。二奶语言也是类似，利用 JVM 平台，想要干掉 Java，然后取而代之。虽然二奶们都在说，我们不是要取代掉 Java。

最后多说点：oop 和 fp 两种范式都在尝试从不同的角度去诠释这个世界罢了，很多人有一个误区，认为这个世界总存在一种一劳永逸的统一的诠释方法，这是有问题的。
人类认识世界的过程是有限的，科学可以接近真理，但永远只是对真理的一种建模，不可能等同于真理本身。就像物理学有相对论和量子力学这种无法统一的理论，他们都是人们眼中对局部自然现象的建模，而非终极自然真理。人类对世界的认识在逐步扩大，但是只能永远接近而无法达到终极自然真理，因为人类的经验是有限的。

**回过头来说 oop 和 fp，任何企图用单一范式来描述世界的语言，就好像希望用量子力学要统一相对论一样可笑。** 很多人写多了 oop 的代码，知道了它的问题，偶尔看下 fp 新奇，却又没接触到 fp 自身的缺陷罢了。
