Java 内存模型规定了一个线程**如何**和**何时**可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

> 简单点(但是不够准确)来说就是，一些规定了线程“操作”变量的规则。

小插曲：内存模型和内存划分不能混为一谈(光看名词确实会不注意搞混淆)，例如我在校招面试时， B 开头的某公司面试官然我说一下 Java 内存模型，我按照上面回答了，他觉得我说的那不叫内存模型，他的意思是，JVM 的堆、栈、方法区等等那些划分叫做内存模型。我的理解是，Java 内存模型不仅仅是内存分区，它是个比内存分区更大的概念。

> 据说原始的 Java 内存模型存在一些不足，因此 Java 内存模型在 JDK1.5 时被重新修订。这个版本的Java 内存模型在 Java8 中仍然在使用。

# 硬件内存架构

![图片.png](https://upload-images.jianshu.io/upload_images/1936544-fad0f3f38a11c43b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


*   多 CPU：如果 Java 程序是多线程的，在 Java 程序中每个 CPU 上一个线程可能同时（并发）执行。

*   CPU 寄存器：每个 CPU 都包含一系列的寄存器，它们是 CPU 内内存的基础，CPU 访问寄存器的速度远大于主存。

*   高速缓存 cache：高速缓存作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。每个 CPU 可能有一个 CPU 缓存层，一些 CPU 还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。

*   内存：所有的 CPU 都可以访问主存。

运作原理：通常情况下，当一个 CPU 需要读取主存时，它会将主存的部分读到 CPU 缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当 CPU 需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。

## 带来的两个问题

1.  **缓存一致性问题：** 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly 及 DragonProtocol等等。
![图片.png](https://upload-images.jianshu.io/upload_images/1936544-752b6e6ffc706d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


2.  **指令重排序问题：** 为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似， Java 虚拟机的 JIT 编译器中也有类似的指令重排序优化。

# Java 内存模型

## 与硬件内存架构之间的桥接

Java内存模型与硬件内存架构之间存在明显的差异，因为硬件内存架构没有区分线程栈和堆。**对于硬件，所有的线程栈和堆都分布在主内存中**，部分线程栈和堆可能有时候会出现在 CPU 缓存中和 CPU 内部的寄存器中。如下图所示：

![图片.png](https://upload-images.jianshu.io/upload_images/1936544-2eb1387438355225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


JVM 是上层，硬件是底层，上层一般为了提供一些特殊功能会对底层做很多抽象。因此要搞清楚两者之间的关系，就要自顶向下去抽象，把抽象关系剥离出来。

从抽象的角度来看，JVM 定义了线程和主内存之间的抽象关系：

*   线程之间的共享变量存储在主内存中

*   每个线程都有一个私有的本地内存，**本地内存是 JVM 的一个抽象概念，并不真实存在**，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程读/写共享变量的拷贝副本。

*   从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。

*   Java内存模型中的线程的工作内存是 cpu 的寄存器和高速缓存的抽象描述。而 JVM 的静态内存储模型只是一种对内存的物理划分而已，它只局限在内存，而且只局限在 JVM 的内存。

## 主内存与工作内存之间的交互

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：

*   lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

*   unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

*   read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

*   load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

*   use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

*   assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

*   store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。

*   write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

*   如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。

*   不允许read和load、store和write操作之一单独出现。

*   不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。

*   不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。

*   一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。

*   一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。

*   如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。

*   如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。

*   对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

## 内存模型建立所围绕的问题

Java 内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争 race condition）。

### 多线程读同步与可见性

未完待续

### 多线程写同步与原子性

未完待续
