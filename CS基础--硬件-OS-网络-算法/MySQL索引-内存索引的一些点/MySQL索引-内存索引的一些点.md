 数据库的点很多很杂，记录下来。

# 磁盘索引和内存索引

## Q: 为何要有B-Tree为代表多叉平衡树和红黑树为代表的二叉平衡树两种索引数据结构？

**B-Tree是为**`**硬盘**`**设计的索引数据结构**

1.  针对硬盘的顺序读写速度优于随机读写速度，B-Tree的单个节点存在多个，这样能让一个指针(引用)不再对应一个键值对，而是对应一个连续的键值区间的键值对集合。

    > 因为多个指针指向的数据不一定是连续，但是一个指针指向的存储区域一定是连续，能够将大量的随机读写转换为局部的顺序读写。

2.  磁盘I/O相对于内存速度存在量级上的差距，B-tree适合做大数据量的索引结构，`整棵树存储在硬盘，读写时将某个节点加载到内存`。

    > 在树形结构中，查询一个数据的最多的I/O次数为树的高度，B-Tree的多叉树结构相对于二叉树高度更低。每次 I/O 将单个 B-Tree 节点加载到内存，在内存中进行二分查找，因此总的开销是：一共要进行 h (B-Tree 的高度)次磁盘 I/O，加上若干次(以 2 为底数，对每个节点的"长度"取对数)的内存二分查找。

**平衡二叉树是为**`**内存**`**设计的索引数据结构**

内存中随机读写与顺序读写速度相当，平衡二叉树存储的数据量较小，整颗树存储到内存,所以使用B-Tree的话，在查找时白白浪费CPU进行二分查找。

## B-tree存储的数据量大，平衡二叉树存储的数据量较小怎么理解，是什么造成这样的差异

因为数据量大，所以必须存到硬盘(在不考虑持久化的问题上)。两种数据结构从视图上都是索引，却在结构上一个更适应内存，一个更适应机械硬盘，所以结论是数据的差异决定了数据结构的选型。造成差异的原因可能是业务决定的，比如一些元数据量就小，日志数据量就大。


# MySQL唯一索引、主键索引、辅助索引的区别

*   主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

*   主键列在创建时，已经默认为`非空值 + 唯一索引`了。

    *   主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键

    *   唯一性索引列允许空值，而主键列不允许为空值

*   主键可以被其他表引用为外键，而唯一索引不能。

*   一个表最多只能创建一个主键，但可以创建多个唯一索引。

*   主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。



另外，在不同的隔离级别下加锁的操作有所不同，以最常用的Repeatable Read为例。

假设在事务中执行语句：`select * from t1 where id = ? for update`

*   当id是`主键`的时候，Mysql会直接找到主键索引，然后将其加锁。

*   当id是`唯一索引`的时候，Mysql会先根据唯一索引找到主键索引，然后将两个索引都加锁。

*   当id是`辅助索引`的时候，Mysql会根据索引找到对应的主键索引（可能会有多个），然后全都加锁。

*   当id`没有索引`的时候，Mysql会给所有记录加上行锁，即锁全表。

> 所以，在给记录加锁的时候，一定要保证 where 的条件列上有索引，否则会导致全表被锁。
